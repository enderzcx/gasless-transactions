/**
 * @file update_readme.js
 * @description Automatically updates the README.md file with data from GitHub Issues.
 * It reads registration and submission issues from JSON files (generated by gh CLI),
 * generates Markdown tables, and replaces specific sections in the README.
 */

const fs = require('fs');
const path = require('path');

// Paths to necessary files
const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
const contributingPath = path.join(workspace, 'CONTRIBUTING.md');
const readmePath = path.join(workspace, 'README.md');
const registrationsPath = process.env.REGISTRATIONS_PATH;
const submissionsPath = process.env.SUBMISSIONS_PATH;

// Helper to extract value from issue body (new format)
// Matches **FieldName** (description) followed by > and the value
function extractValueNewFormat(body, fieldName) {
  if (!body) return '';

  // Create regex to match **FieldName** followed by content in parentheses, then >
  const lines = body.split('\n');
  let foundField = false;
  let value = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Check if this line contains our field
    if (line.includes(`**${fieldName}**`)) {
      foundField = true;
      continue;
    }

    // If we found the field, look for the > line
    if (foundField && line.startsWith('>')) {
      value = line.substring(1).trim();
      // Continue collecting multi-line values
      for (let j = i + 1; j < lines.length; j++) {
        const nextLine = lines[j].trim();
        // Stop if we hit another field or empty line followed by **
        if (nextLine.startsWith('**') || nextLine.startsWith('#')) {
          break;
        }
        if (nextLine && !nextLine.startsWith('>')) {
          value += '\n' + nextLine;
        }
      }
      break;
    }

    // Reset if we hit another field without finding a value
    if (foundField && line.startsWith('**')) {
      foundField = false;
    }
  }

  return value.trim();
}

/**
 * Formats text for a Markdown table cell.
 * - Escapes pipe characters '|' to prevent breaking table structure.
 * - Replaces newlines with <br> tags for multi-line support within a cell.
 * @param {string} text - The input text
 * @returns {string} Formatted text safe for Markdown tables
 */
function formatCol(text) {
  if (!text) return '-';
  return text.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br>');
}

/**
 * Generates the Markdown table for Registrations.
 * Columns: Name, GitHub ID, Introduction, Contact, Wallet, WantsTeam, Track, Comment, Link
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateRegistrationTable(issues) {
  // Define Table Header (removed GitHub ID and Wallet Address columns)
  let table = '| # | ÂßìÂêç | ‰∏™‰∫∫‰ªãÁªç | ËÅîÁ≥ªÊñπÂºè | ÁªÑÈòüÊÑèÊÑø | ËµõÈÅìÈÄâÊã© | Â§áÊ≥® | Êõ¥Êñ∞ËµÑÊñô |\n';
  table += '| --- | --------- | -------- | -------- | -------- | -------- | ---- | -------- |\n';

  // Return placeholder if list is empty
  if (!issues || issues.length === 0) {
    table += '| - | ÂæÖÊõ¥Êñ∞... | - | - | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach((issue, index) => {
    const body = issue.body || '';

    // Extract fields based on the new template structure: **FieldName** followed by >
    const name = extractValueNewFormat(body, 'Name') || (issue.title || '').replace('[Êä•Âêç] ', '');
    const introduction = extractValueNewFormat(body, 'Introduction');
    const contact = extractValueNewFormat(body, 'ContactMethod');
    const wantsTeam = extractValueNewFormat(body, 'WantsTeam');
    const track = extractValueNewFormat(body, 'Track');
    const comment = extractValueNewFormat(body, 'Comment');

    const issueUrl = issue.url;

    table += `| ${index + 1} | ${formatCol(name)} | ${formatCol(introduction)} | ${formatCol(contact)} | ${formatCol(wantsTeam)} | ${formatCol(track)} | ${formatCol(comment)} | [ÁºñËæë](${issueUrl}) |\n`;
  });

  return table;
}

/**
 * Generates the Markdown table for Project Submissions.
 * Columns: ProjectName, Track, GitHub ID, Description, Team Lead, Repo Link, Date
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateSubmissionTable(issues) {
  // Define Table Header (removed GitHub ID and submission time, added operation column)
  let table = '| # | È°πÁõÆÂêçÁß∞ | ËµõÈÅì | È°πÁõÆÊèèËø∞ | Ë¥üË¥£‰∫∫ | È°πÁõÆÈìæÊé• | Êìç‰Ωú |\n';
  table += '| --- | --------- | --------- | -------- | -------- | -------- | -------- |\n';

  if (!issues || issues.length === 0) {
    table += '| - | ÂæÖÊõ¥Êñ∞... | - | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach((issue, index) => {
    const body = issue.body || '';

    // Extract fields based on the new template structure: **FieldName** followed by >
    const projectName = extractValueNewFormat(body, 'ProjectName') || (issue.title || '').replace('[Êèê‰∫§] ', '');
    const track = extractValueNewFormat(body, 'Track');
    const description = extractValueNewFormat(body, 'ProjectDescription');
    const repoLink = extractValueNewFormat(body, 'Github Repo Link');
    const teamLead = extractValueNewFormat(body, 'Team Lead');

    const issueUrl = issue.url;

    table += `| ${index + 1} | ${formatCol(projectName)} | ${formatCol(track)} | ${formatCol(description)} | ${formatCol(teamLead)} | [üîó](${repoLink}) | [ÁºñËæë](${issueUrl}) |\n`;
  });

  return table;
}

/**
 * Replaces a section of text between two markers with new content.
 * Used to inject the generated tables into specific spots in README.md.
 * @param {string} content - The original file content
 * @param {string} startMarker - The marker string indicating start of section
 * @param {string} endMarker - The marker string indicating end of section
 * @param {string} newContent - The new content to insert
 * @returns {string} The modified content
 */
function replaceSection(content, startMarker, endMarker, newContent) {
  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    console.warn(`Markers not found: ${startMarker}, ${endMarker}`);
    return content;
  }

  // Reconstruct file: Part before marker + Marker + New Content + Part after end marker
  // Note: We deliberately add newlines for formatting
  return content.substring(0, startIndex + startMarker.length) + '\n\n' + newContent + '\n' + content.substring(endIndex);
}

// --- Main Execution ---
try {
  let registrations = [];
  let submissions = [];

  // Read CONTRIBUTING.md
  let contributingContent = fs.readFileSync(contributingPath, 'utf8');

  // 1. Process Registrations Table
  if (fs.existsSync(registrationsPath)) {
    registrations = JSON.parse(fs.readFileSync(registrationsPath, 'utf8'));
    console.log(`Found ${registrations.length} registrations.`);
    if (registrations.length > 0) {
      const regTable = generateRegistrationTable(registrations);

      // Update CONTRIBUTING.md
      contributingContent = replaceSection(contributingContent, '<!-- Registration start -->', '<!-- Registration end -->', regTable);
    } else {
      console.log('Registrations list is empty, skipping registration update.');
    }
  } else {
    console.log('No registrations file found, skipping registration update.');
  }

  // 2. Process Submissions Table
  if (fs.existsSync(submissionsPath)) {
    submissions = JSON.parse(fs.readFileSync(submissionsPath, 'utf8'));
    console.log(`Found ${submissions.length} submissions.`);
    if (submissions.length > 0) {
      const subTable = generateSubmissionTable(submissions);

      // Update CONTRIBUTING.md
      contributingContent = replaceSection(contributingContent, '<!-- Submission start -->', '<!-- Submission end -->', subTable);
    } else {
      console.log('Submissions list is empty, skipping submission update.');
    }
  } else {
    console.log('No submissions file found, skipping submission update.');
  }

  // Write changes back to CONTRIBUTING.md
  fs.writeFileSync(contributingPath, contributingContent);
  console.log('CONTRIBUTING.md updated successfully.');

  // Update README summary only (counts)
  if (fs.existsSync(readmePath)) {
    let mainReadme = fs.readFileSync(readmePath, 'utf8');
    const summaryContent = `Êä•Âêç‰∫∫Êï∞Ôºö${registrations.length}ÔΩúÊèê‰∫§‰∫∫Êï∞Ôºö${submissions.length}ÔºàÂêçÂçïËØ¶ËßÅ \`CONTRIBUTING.md\`Ôºâ`;
    mainReadme = replaceSection(mainReadme, '<!-- Registration summary start -->', '<!-- Registration summary end -->', summaryContent);
    fs.writeFileSync(readmePath, mainReadme);
    console.log('README summary updated successfully.');
  }

} catch (error) {
  console.error('Error updating README:', error);
  process.exit(1);
}
