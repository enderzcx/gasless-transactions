/**
 * @file update_readme.js
 * @description Automatically updates the README.md file with data from GitHub Issues.
 * It reads registration and submission issues from JSON files (generated by gh CLI),
 * generates Markdown tables, and replaces specific sections in the README.
 */

const fs = require('fs');
const path = require('path');

// Paths to necessary files
const readmePath = path.join(process.env.GITHUB_WORKSPACE, 'README.md');
const registrationsPath = process.env.REGISTRATIONS_PATH;
const submissionsPath = process.env.SUBMISSIONS_PATH;

// Helper to extract value from issue body
// Matches **Key:** ...value... until the next **Key:** or End of String
function extractValue(body, keyRegex) {
  if (!body) return '';

  // Find the start of the key
  const match = body.match(keyRegex);
  if (!match) return '';

  // Start extracting after the matched key
  const startIndex = match.index + match[0].length;
  let remaining = body.substring(startIndex);

  // If the key was wrapped in bold (e.g. **Key:**), the trailing ** might be here.
  // Remove it if present.
  if (remaining.startsWith('**')) {
    remaining = remaining.substring(2);
  }

  // Find the start of the next key to determine where the current value ends.
  // We assume the next key starts on a new line with **, and contains a colon.
  // This is a common pattern in the provided templates.
  const nextKeyRegex = /\r?\n\s*\*\*.*(:|：)/;
  const nextMatch = remaining.match(nextKeyRegex);

  let value = '';
  if (nextMatch) {
    value = remaining.substring(0, nextMatch.index);
  } else {
    value = remaining;
  }

  return value.trim();
}

/**
 * Formats text for a Markdown table cell.
 * - Escapes pipe characters '|' to prevent breaking table structure.
 * - Replaces newlines with <br> tags for multi-line support within a cell.
 * @param {string} text - The input text
 * @returns {string} Formatted text safe for Markdown tables
 */
function formatCol(text) {
  if (!text) return '-';
  return text.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br>');
}

/**
 * Generates the Markdown table for Registrations.
 * Columns: Name, GitHub ID, Contact, WantsTeam, Comment, Link
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateRegistrationTable(issues) {
  // Define Table Header
  let table = '| 姓名 | GitHub ID | 联系方式 | 组队意愿 | 备注 | 更新资料 |\n';
  table += '| --------- | --------- | -------- | -------- | ---- | -------- |\n';

  // Return placeholder if list is empty
  if (!issues || issues.length === 0) {
    table += '| 待更新... | - | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach(issue => {
    const body = issue.body || '';

    // Extract fields based on the "register.md" template structure
    // Improved Regex keys to match the exact template structure
    // We look for the literal strings used in the template
    const name = extractValue(body, /\*\*Name \[姓名\]:/);
    const contact = extractValue(body, /\*\*ContactMethod.*?(:|：)/); // Handle potential Chinese colon
    const wantsTeam = extractValue(body, /\*\*WantsTeam.*?(:|：)/);
    const comment = extractValue(body, /\*\*Comment.*?(:|：)/);

    const githubId = issue.author ? issue.author.login : 'unknown';
    const issueUrl = issue.url;

    table += `| ${formatCol(name)} | [@${githubId}](https://github.com/${githubId}) | ${formatCol(contact)} | ${formatCol(wantsTeam)} | ${formatCol(comment)} | [Link](${issueUrl}) |\n`;
  });

  return table;
}

/**
 * Generates the Markdown table for Project Submissions.
 * Columns: ProjectName, GitHub ID, Description, Repo Link, Date
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateSubmissionTable(issues) {
  // Define Table Header
  let table = '| 项目名称 | GitHub ID | 项目描述 | 项目链接 | 提交时间 |\n';
  table += '| --------- | --------- | -------- | -------- | -------- |\n';

  if (!issues || issues.length === 0) {
    table += '| 待更新... | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach(issue => {
    const body = issue.body || '';

    // Extract fields based on the "submission.md" template structure
    const projectName = extractValue(body, /\*\*ProjectName.*?(:|：)/);
    const description = extractValue(body, /\*\*Brief description.*?(:|：)/); // Should match the one sentence description
    const repoLink = extractValue(body, /\*\*Github Repo Link.*?(:|：)/);

    const githubId = issue.author ? issue.author.login : 'unknown';
    // Format date as YYYY-MM-DD
    const date = issue.createdAt ? issue.createdAt.split('T')[0] : '-';

    table += `| ${formatCol(projectName)} | [@${githubId}](https://github.com/${githubId}) | ${formatCol(description)} | [Repo](${repoLink}) | ${date} |\n`;
  });

  return table;
}

/**
 * Replaces a section of text between two markers with new content.
 * Used to inject the generated tables into specific spots in README.md.
 * @param {string} content - The original file content
 * @param {string} startMarker - The marker string indicating start of section
 * @param {string} endMarker - The marker string indicating end of section
 * @param {string} newContent - The new content to insert
 * @returns {string} The modified content
 */
function replaceSection(content, startMarker, endMarker, newContent) {
  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    console.warn(`Markers not found: ${startMarker}, ${endMarker}`);
    return content;
  }

  // Reconstruct file: Part before marker + Marker + New Content + Part after end marker
  // Note: We deliberately add newlines for formatting
  return content.substring(0, startIndex + startMarker.length) + '\n\n' + newContent + '\n' + content.substring(endIndex);
}

// --- Main Execution ---
try {
  // Read current README
  let readmeContent = fs.readFileSync(readmePath, 'utf8');

  // 1. Process Registrations Table
  if (fs.existsSync(registrationsPath)) {
    const registrations = JSON.parse(fs.readFileSync(registrationsPath, 'utf8'));
    console.log(`Found ${registrations.length} registrations.`);
    const regTable = generateRegistrationTable(registrations);
    readmeContent = replaceSection(readmeContent, '<!-- Registration start -->', '<!-- Registration end -->', regTable);
  } else {
    console.log('No registrations file found, skipping registration update.');
  }

  // 2. Process Submissions Table
  if (fs.existsSync(submissionsPath)) {
    const submissions = JSON.parse(fs.readFileSync(submissionsPath, 'utf8'));
    console.log(`Found ${submissions.length} submissions.`);
    const subTable = generateSubmissionTable(submissions);
    readmeContent = replaceSection(readmeContent, '<!-- Submission start -->', '<!-- Submission end -->', subTable);
  } else {
    console.log('No submissions file found, skipping submission update.');
  }

  // Write changes back to README
  fs.writeFileSync(readmePath, readmeContent);
  console.log('README.md updated successfully.');

} catch (error) {
  console.error('Error updating README:', error);
  process.exit(1);
}
